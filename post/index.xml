<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on メモを書いておくページ</title>
    <link>https://tkconq.github.io/post/</link>
    <description>Recent content in Posts on メモを書いておくページ</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; tkconq 2019. All rights reserved.</copyright>
    <lastBuildDate>Fri, 27 Sep 2019 15:03:12 +0900</lastBuildDate>
    
	<atom:link href="https://tkconq.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>アジャイル開発</title>
      <link>https://tkconq.github.io/post/20190927/</link>
      <pubDate>Fri, 27 Sep 2019 15:03:12 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190927/</guid>
      <description> アジャイル開発とは  短い開発期間でイテレーションを回していく  優先度の高い重要な機能から着手できる   アジャイル開発の手法 スクラム開発  開発を進めるためのフレームワーク メンバーが自分たちで計画を立案し、イテレーションごとに開発の進行に問題がないか確認
エクストリームプログラミング 事前に立てた計画よりも途中変更などの柔軟性を重視
  ユーザ機能駆動開発（FDD)  実際に動作するソフトウェアを適切な感覚で繰り返す手法  スクラムガイド  https://www.scrumguides.org/docs/scrumguide/v2016/2016-Scrum-Guide-Japanese.pdf  スクラムの定義  軽量 理解が容易 習得は困難   スクラムの理路  透明性  結果責任を持つものに対して見える化されていること。見ている人が共通理解を持つこと  検査  スクラムのユーザはスクラムの成果物や進捗を頻繁に検査し、変化を検知する  適応  プロセスの不備が許容値を超え、成果となるプロダクトを受け入れられないと検査人が判断した場合は、プロセスやその構成を調整する。   スクラムの価値基準  確約、勇気、集中、公開、尊敬  スクラムチーム  プロダクトオーナー  開発チームの作業とプロダクトの価値の最大化に責任を持つ プロダクトバックログアイテムを明確に表現する ゴールとミッションを達成できるようにプロダクトバックログアイテムを並び替える 開発チームが行う作業の価値を最適化する プロダクトバックログを全員に見える化・透明化・明確化し、スクラムチームが次に行う作業を示す。  開発チーム  開発チームは、自分たちの作業を構成・管理する。 自己組織化されている 機能横断的である。 ある人にしかできない作業があったとしても、メンバーの肩書は開発者だけである。このルールに例外はない。 開発チームに最適な人数は、小回りが利く程度に少なく、１つのスプリントで重要な作業が成し遂げられる程度に多い。  スクラムマスター  スクラムの理解と成立に責任を持つ スクラムマスターはサーバントリーダーである（メンバーが成果を上げるために支援や奉仕するリーダーのこと） スクラムマスターは、プロダクトオーダーを支援する 効果的なプロダクトバックログの管理方法を探す 明確で簡潔なプロダクトバックログアイテムの必要性についてスクラムチームに理解してもらう プロダクトプランニングについて理解する。 スクラムイベントをファシリテートする スクラムマスターは開発チームを支援する 自己組織化・機能横断的な開発チームをコーチする 開発チームが価値の高いプロダクトを作れるように支援する 開発チームの進捗を妨げるものを除外する   スクラムイベント  スクラムで規定されたイベントは規則性を作りだし、スクラムで定義されていないミーティングの必要性を最小化する 時間に上限のあるタイムボックス化されたイベントである。 スプリントを開始すると、その期間は固定化され、増減することはできない。 スプリント以外のスクラムイベントは何かを検査・適応するための正式な機会。  スプリント  スクラムの中心はスプリントである。 完成した、利用可能な、リリース判断可能なプロダクトインクリメントを作るための、１か月以下のタイムボックスである。 スプリントでは次のことを行う  スプリントゴールに悪影響を及ぼす変更を加えない 品質目標を下げない 学習が進むにつれてスコープが明確化され、プロダクトオーナーと開発チームの交渉が必要になる可能性がある。  スプリントは１か月以内のプロジェクトと考えることができる。 スプリントの期間は１か月以内に制限される。  スプリントの中止  スプリントはタイムボックスの終了前に中止できる。 スプリントゴールが古くなった場合は、スプリントを中止する。 中止した場合  プロダクトバックログの完成したアイテムをレビューする 部分的にリリース判断可能なものがあればプロダクトオーナーが受け入れる。   スプリントプランニング  スプリントの作業はスプリントプランニングで計画する。これはスクラムチームの共同作業。 スプリントが１か月の場合、スプリントプランニングのタイムボックスは最大で８時間  スプリントの成果物であるインクリメントで何を届けるか インクリメントを届けるために必要な作業をどのように成し遂げるか   トピック：スプリントでできること  開発チーム：スプリントで開発する機能を予想する プロダクトオーナー：スプリントで達成すべき目的と、完成後にスプリントゴールを達成するプロダクトバックログアイテムについて検討する。  トピック：選択した作業をどのように成し遂げるか  プロダクトバックログアイテムを選択し、スプリントゴールを設定したら、開発チームはそれらの機能をスプリントで「完成」プロダクトインクリメントにする方法を決める。 開発チームは、プロダクトバックログを動作するプロダクトインクリメントにかえるために必要なシステムと作業の設計から着手する プロダクトオーナーは選択したプロダクトバックログアイテムの明確化やトレードオフを支援する。  スプリントゴール  スプリントゴールはスプリントの目標セットであり、プロダクトバックログの実装によって実現する  デイリースクラム  開発チームが活動の速度を合わせ、次の24時間の計画を作る15分間のタイムボックスのイベントである。 開発チームがやること  機能やったこと、今日やること、障害があったか。  スクラムマスター  デイリースクラムを開催してもらうように依頼。デイリースクラムは開発チームのメンバーのみ参加を厳守   スプリントレビュー  スプリントの終わりにインクリメントの検査と、必要であればプロダクトバックログの適応を行う。 スプリントが１か月であれば、スプリントレビューのタイムボックスは4時間である。 プロダクトオーナーの仕事  参加者の招待 プロダクトバックログアイテムの完成したものと完成していないものの説明 現在のプロダクトバックログの審議  開発チームの説明  スプリントでうまくいったこと 直面した問題点 どのように解決したか   スプリントレトロスペクティブ  スクラムチームの検査と、次のスプリントの改善計画を作成する機会 スプリントレビューが終わり、次のスプリントプランニングが始まる前に行う スプリントが１か月の場合、スプリントレトロスペクティブのタイムボックスは３時間である。 スプリントレトロスペクティブの目的  人・関係・プロセス・ツールの観点からスプリントを検査 うまくいった項目や今後の改善が必要な項目を特定・整理 スクラムチームの作業の改善実施計画を作成   スクラムの成果物  作業や価値を表したもの  プロダクトバックログ  プロダクトに必要なものがすべて並べられた一覧 プロダクトに対する変更要求の唯一の情報源である。 プロダクトバックログは消して完成しない。動的なもの 詳細・並び順・見積もり・価値の属性をもつ  ゴールへの進捗を監視する  開発ゴールに対する残作業時間を合計する。  スプリントバックログ  開発チームが作成するインクリメントに含まれる機能と、その機能を「完成」インクリメントにして届けるために必要な作業の予想 スプリントバックログは十分に詳細であり、今後も変更される可能性のある計画である。 デイリースクラムで理解できる程度のものである。  インクリメント  これまでのインクリメントの価値と今回のスプリントで完成したプロダクトバックログアイテムをあわせたもの。 スプリントの終わりには、新しいインクリメントが「完成」していなければならない。  </description>
    </item>
    
    <item>
      <title>SA午後</title>
      <link>https://tkconq.github.io/post/20190923/</link>
      <pubDate>Mon, 23 Sep 2019 21:31:58 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190923/</guid>
      <description> 企業の主要業務パターン  販売管理業務  売掛: あとで代金を受取る約束で売ること 引当て:ものを準備すること  生産管理業務  部品表:製品が原材料と半製品によってどのように構成されているかを示す 所要量計算: 部品表を使って生産に必要な原材料と半製品を算出する  購買管理業務  納品日=発注+購入リードタイム 品物と納品書を受け入れる。注文した側は「受入」、物品を受注した側は「納品」 検収: 納品書、発注情報、受け入れた品物の３つを確認すること  物流管理業務  棚入れ：入荷実績を元に、在庫マスタを更新し、棚入れする原材料や製品などに棚番を割り当てる   </description>
    </item>
    
    <item>
      <title>イチから理解するサーバーレスアプリ開発</title>
      <link>https://tkconq.github.io/post/20190905/</link>
      <pubDate>Thu, 05 Sep 2019 14:52:43 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190905/</guid>
      <description>アジェンダ  サーバーレスのおさらい エラー制御・監視の勘所 サーバーレスアプリケーション向きのDB設計ベストプラクティス  サーバーレスのおさらい  サーバーレスとは  主要コンポーネントのおさらい  リソースのエラー制御の基本 サーバーレスにおけるDBの考え方 パターンで考える  サーバーレス基本  サーバレスはサーバの存在を意識しない  サーバ管理不要 柔軟なスケーリング 十二分に考慮された高可用性 アイドル時のリソース確保不要  サーバーレスアプリケーション  利用者がやること アプリケーション設計 ロジック開発/DB設計 監視・エラー制御 クラウドがやること リソース管理 再実行処理 ログ管理 サーバー保守  Function as a Service: AWS Lambda  実行時に適切にインフラを確保して処理を実行 Lambda関数はVPCでは遅かったが、改善された  外部I/F  REST API: API Gateway GraphQL: AppSync  処理ロジック  AWS Lambda  データ管理  NoSQL: DynamoDB RDB: RDS/Aurora Queue: SQS File: S3  認証: Cognito ストリーム  流入データ: Kinesis Data Stream 流入ログ: Kinesis Firehose  実践でよく使われるユースケースパターン  https://aws.</description>
    </item>
    
    <item>
      <title>漫画で分かるデザイン思考</title>
      <link>https://tkconq.github.io/post/20190820/</link>
      <pubDate>Tue, 20 Aug 2019 09:57:21 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190820/</guid>
      <description> 目次  創造的覚悟 着想１．潜在的ニーズ 着想２．普通を見直す 着想３．カスタマージャーニー 発案１．ブレインストーミング 発案２．プロトタイピング 実現. プレゼンテーション  創造的覚悟  デザイン思考はイノベーションを起こすプロセス イノベーション：新しいアイデアの実践を通して価値を創造する人々  潜在的ニーズ  デザイン思考：着想、発案、実現のプロセス
 着想：ソリューションを探り出すきっかけになる問題や機会 発案：アイデアを創造、構築、検証するプロセス 実現：アイデアをプロジェクトルームから市場へと導く工程  表面化されたニーズ：対応するモノ・サービスがすでに市場に存在する
 潜在的ニーズ：まだ誰も気づいていないか、市場に存在するモノ・サービスでは満たされていないニーズ
 観察で潜在的ニーズを見つける。
 人間に直接聞くと正直な感想を言ってくれない可能性あり 統計データ分析はデータの切り取り方によって見え方がまったく異なる可能性あり 観察は「人間の行動」を見る。人間の行動は本質的欲求の現れ  想像力は誰にでもある。以下の信念が必要
 自分には想像力がある 自分には周囲の世界を変える力がある。   着想２．普通を見直す  共感マップ  対象がどんな言動の時にどんな感情だったか。言葉、行動に感情を紐づけて観察する。 以下の表に埋めていく。Say,Doが埋まった後にThink,Feelを埋める Say: 言ったこと Do: した事 THINK: 考えている（と思われること） FEEL: 感じている（と思われること） 付箋の使い分け 悲しみ・怒り・疲れなどのネガティブな感情には青色のふせん 喜び・リラックスなどのポジティブな感情には赤色のふせん 感情が判別できなくても気になることには黄色のふせん 作業終了後にマップ全体を俯瞰して、各エリアの間にギャップが存在すればそれは潜在的ニーズを発見するチャンス   観察を成功させるための心得  「人間の抱える基本的な問題とは、人間は不便な状況に適応するのに長けている」 １．自分の常識・経験・思い込みで判断しない 「他社の目を通じて世界を観察し、他社の経験を通して世界を理解し、他社の感情を通じて世界を感じ取る」 ２．意味不明または無意味に思える行動・仕草を見逃さない 「いかなる場合も観察対象である人間が正しい」 「一見すると説明不能な人々の行動が、厄介で複雑で矛盾した世界に対処するための戦略」 ３．感情と行動を連動させて観察する 「どの行動」をした時「どんな感情」だったかを紐づけて観察する 舌打ちやため息などネガティブな感情を示したその時、そこにはなんらかの不便やわずらわしさが存在   着想３．カスタマージャーニー  カスタマージャーニー  顧客がモノ・サービスを利用する過程を「旅」に見立てて書き出す 最初に顧客が利用する過程をリストアップし、時系列に並べる。 次に顧客を観察し、共感マップと同じように色分けした付箋を使い、リストアップした顧客の旅に該当するスペースに張っていく。 ギャップと改善点が無いか検証する。 顧客の経験を段階ごとに区切って検証することで、モノ・サービスのどこが長所でどこが短所なのかを顕在化させる。 平凡な経験も認識しやすく、これをポジティブな経験に帰ることで全体的な満足度を上げることができる  「いかなる個人よりも全員の方がか賢い」 エクストリームユーザーを観察  少数派の「極端な利用者」のこと 平均的なユーザは不満があってもそれを受け入れて利用する エクストリームユーザーはマニュアルを無視して独自の使い方をする この行動には潜在的ニーズが存在する可能性あり。  デザイン思考は「経験」をデザインする  例えば「レジの待ち時間が長い」とクレームがあった時に「待ち時間を短くするにはどうすればいいか」と考えるのは悪手 「待ち時間が長い」と思わずに自分のレジ番にたどりつける経験を提供する    発想① ブレインストーミング  潜在的ニーズを発見できたならば、プロセスは「着想」から「発案」に移る。 アイデアの多様性と量が「良いアイデア」につながる  アイデアの質より量にこだわる 他社のアイデアをもとにして飛躍する 上下関係による影響を排除する 自己防衛審を取り除く 支配欲に気を付ける 制限時間１時間、目標アイデア数①００個 簡単なクラフトツールを用意する どの案を採用するかは多数決  BSの進行と進行役の心がけ  テーマ設定は、アイデアがすぐに１０個でるように 場の流れを停滞させない。 アイデアを付箋に書き込み、はっていく 重要なルールは壁に貼る   プロトタイピング プレゼンテーション </description>
    </item>
    
    <item>
      <title>My work</title>
      <link>https://tkconq.github.io/post/20190819/</link>
      <pubDate>Mon, 19 Aug 2019 23:18:56 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190819/</guid>
      <description>Introduction My job is a system engineer. I work in Tokyo on weekdays. I often create some software using some programming languages. I usually use Python, Java and so on. However, I&amp;rsquo;ve not made software recently.</description>
    </item>
    
    <item>
      <title>Pokemon Card</title>
      <link>https://tkconq.github.io/post/20190818/</link>
      <pubDate>Sun, 18 Aug 2019 21:47:02 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190818/</guid>
      <description>Pokemon Card I have enjoyed Pokemon card since one year ago. I like the card game because the card design is very cute. I play the game with my friends every Saturday. Today, a tournament is held to decide the World Champion in America. I am watching the tournament. The players play very technical. I think that I need the skill. So I have to practice the card more than ever before.</description>
    </item>
    
    <item>
      <title>３章’実践的なコンテナの構築とデプロイ</title>
      <link>https://tkconq.github.io/post/20190817/</link>
      <pubDate>Sat, 17 Aug 2019 18:55:41 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190817/</guid>
      <description> アプリケーションとコンテナの粒度  1コンテナ1アプリケーションは間違い Each container should have only one concern  コンテナのポータビリティ  ポータビリティは完璧ではない Kernel・アーキテクチャの違いの影響あり ダイナミックリング multi-stage builds という仕組みあり  Dockerフレンドリーなアプリケーション  実行時引数として値を渡す 実行時引数が増えるとマッピング処理が増えたりCMDが複雑になる 設定ファイルとして渡す 昔流行った方法 特定の環境の設定ファイルをDockerイメージに閉じ込めるとポータビリティが狭まる。 アプリケーションの挙動を環境変数で制御する ちょっとした値の変更でDockerイメージをビルドする必要なし 設定ファイルに環境変数を埋め込む SpringFrameworkのpropertiesファイルとか。  永続化データをどう扱うか  Data Volume Dockerコンテナ内のディレクトリを永続化するための仕組み Data Volumeコンテナ データを持つだためだけのコンテナ  コンテナ配置戦略  Docker Swarm 複数のDockerホストを束ねてクラスタ化するためのツール  Compose: 複数のコンテナを使うDockerアプリの管理 Swarm: クラスタの構築や管理 Service: Swarm前提。クラスタ内のServiceを管理 Stack: Swarm前提。複数のServiceをまとめたアプリ全体の管理  Service シングルDockerホストであればdocker container runでやってた Swarmの場合はアプリを構成する一部のコンテナを制御するため単位 Stack 複数のServiceをグルーピングした単位   </description>
    </item>
    
    <item>
      <title>KeyBoard</title>
      <link>https://tkconq.github.io/post/20190816/</link>
      <pubDate>Fri, 16 Aug 2019 22:56:09 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190816/</guid>
      <description>はじめに USキーボードにした。
Introduction I bought US keyboard. It is first time for me to use US Keyboard.</description>
    </item>
    
    <item>
      <title>自作PC</title>
      <link>https://tkconq.github.io/post/20190815/</link>
      <pubDate>Thu, 15 Aug 2019 20:28:10 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190815/</guid>
      <description>自作PC パソコンを買い換える時期は一般にどんなものなのか。 一般的に5年くらいもつらしいが、私の場合は1年ごとに変えている。 最近の流行りを調べてみた。
自作P CPU 今はRyzen一色だろう。価格comでもTOP3はRyzenである。 一番人気はRyzen 9 3900X。12コアの3.8GHzである。 比較対象のCore i9 9900Kの２倍の性能で価格が同じ。 最近はAMDの圧勝だね。
GPU GeForceとRadeonがいい試合をしているらしい。 2080は大体7万5千。いつもグラボは３万前後を買っているのでこれは高い。 二番人気はRadeon RX Vega 64で３万５千。 今使っているのが1070なのでスペック的にはそんなに変わらず。
メモリ F4-3600C19D-32GSXWB [DDR4 PC4-28800 16GB 2枚組]が2万円。 これは安い。私が作ったときの半額くらいか。 普通に欲しい。
SSD MX500が7000円。安い。 そもそも128GBでも困っていないのだが。 最近はPCIeスロットに指すタイプも出ており、1TBで1万2千円。 どれだけ早くなるんだろうか。欲しい。</description>
    </item>
    
    <item>
      <title>シェルとか</title>
      <link>https://tkconq.github.io/post/20190814/</link>
      <pubDate>Wed, 14 Aug 2019 11:09:09 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190814/</guid>
      <description>はじめに シェル遍歴についてのメモ
bash デフォルトのshell。（拡張すればよいのだが）ところどころ不便なこともあってあまり使わなかった。
fish 色々と便利だったが、bashと完全互換しているわけではなく、一部コマンドが使えなかったのでやめた。
zsh oh-my-zshを入れて使っていた。一時期fishにしていたが結局これにもどってきた。</description>
    </item>
    
    <item>
      <title>実家のWindowsが遅い</title>
      <link>https://tkconq.github.io/post/20190813/</link>
      <pubDate>Tue, 13 Aug 2019 11:02:18 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190813/</guid>
      <description>はじめに 実家に以前買ってあげたノートパソコンがめちゃくちゃ重い。 ディスク使用量が100%を常に出しており、これはヤバいと思ったので色々と対策。
溜まっているWindows Updateを順次かける windows updateが無視され続けており、たまっていたのでたくさんかける。 途中で常にupdateが失敗するようになってしまい、Windowsの初期化をしてやり直す。 が、だめ。
Windows 10　を最新にする Windows自体を手動アップデート。うまくいくかはわからないので様子見中</description>
    </item>
    
    <item>
      <title>帰省</title>
      <link>https://tkconq.github.io/post/20190812/</link>
      <pubDate>Mon, 12 Aug 2019 14:59:00 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190812/</guid>
      <description>帰省します。 多少家が広くなるし、勉強に集中できる環境になるはず。</description>
    </item>
    
    <item>
      <title>お盆休みにやること</title>
      <link>https://tkconq.github.io/post/20190811/</link>
      <pubDate>Sun, 11 Aug 2019 12:32:54 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190811/</guid>
      <description>はじめに 10連休ほどもらえたのでこの休み中にやることをまとめる
英語 しばらく休んでいたので基礎から。来月にはSkype英会話を再開できるレベルにはしておきたい。 一応仕事でまた使うことになりそうなのでヤバい。
 英語耳 どんどん話すための瞬間英作文 スタディサプリEnglish  技術書 直近の記事で書いたけど、k8sの教科書を学ぶ。 勉強のモチベーションが下がっているのは、直近仕事で使わないからかな。
 Docker/Kubernetes実践コンテナ開発入門   そもそも 最近新しいことを学ぶ速度が落ちている気がする。 歳のせいか、なかなか頭に残らない。 もともと物覚えは悪い方なので学ぶ時間を増やさなきゃと思いつつ、なかなか重い腰が上がらない。 20代も残り少なくなってきたので、悔いの残らない人生にしないとな。</description>
    </item>
    
    <item>
      <title>Docker/Kubernetes実践コンテナ入門</title>
      <link>https://tkconq.github.io/post/20190810/</link>
      <pubDate>Sat, 10 Aug 2019 09:00:34 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190810/</guid>
      <description>はじめに Docker及びKubernetesについて断片的な知識しかないため、この本を読むことにした
 Docker/Kubernetes 実践コンテナ開発入門
目次 目次はこんな感じ。
 Dockerの基礎 Dockerコンテナのデプロイ 実践的なコンテナの構築とデプロイ Swarmによる実践的なアプリケーション構築 Kubernetes入門 Kubernetesのデプロイ・クラスタ構築 Kubernetesの発展的な利用 コンテナの運用 より軽量なDockerイメージを作る Dockerの様々な活用方法  進捗 2章まで読み終わったとこ。実際に手を動かすことが多いので勉強にはなっている。この休みを利用して一通り終わらせたいと思っている。 やりたいことはたくさんあるので計画的に進めていきたい。</description>
    </item>
    
    <item>
      <title>Circle CI</title>
      <link>https://tkconq.github.io/post/20190809/</link>
      <pubDate>Fri, 09 Aug 2019 08:50:16 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190809/</guid>
      <description>CircleCIとは クラウドのCI/CDのデファクトといっていいもの。GitHubと連携できるので相性が良い。（とはいえ今どきのCI/CDツールなら大抵連携できる)  Circle CIのイメージ   URL: https://circleci.com/
blog運営に使うだけであれば無料枠で十分。 configの設定は以下の通り。 themesをsubmoduleで管理していたところ、circleci側でうまくgit cloneできずに少しハマった。とりあえず本体で管理する解決策で代用。特にテーマ変える予定もいまのところないしね。
version: 2 jobs: build: docker: - image: cibuilds/hugo:latest steps: - checkout - run: name: &amp;quot;Setting for Git&amp;quot; command: | git config --global user.name &amp;quot;&amp;lt;yourname&amp;gt;&amp;quot; git config --global user.email &amp;quot;&amp;lt;yourname&amp;gt;@gmail.com&amp;quot; - run: name: &amp;quot;Get GitHub repository&amp;quot; command: git clone git@github.com:&amp;lt;yourname&amp;gt;/blog.git - run: name: &amp;quot;Build &amp;amp; Push&amp;quot; command: | git clone --recursive git@github.com:&amp;lt;yourname&amp;gt;/&amp;lt;yourname&amp;gt;.github.io.git public hugo cd public ls git add .</description>
    </item>
    
    <item>
      <title>Hugo &#43; GitHub Pagesでブログ作成した</title>
      <link>https://tkconq.github.io/post/20190808/</link>
      <pubDate>Thu, 08 Aug 2019 23:04:08 +0900</pubDate>
      
      <guid>https://tkconq.github.io/post/20190808/</guid>
      <description>はじめに 普段からMarkdownで文章を書くことが多いため、blogもMarkdownで書きたいなと思った。 候補はいくつかあったが、とりあえずそこそこ王道であるHugoとGitHubを組み合わせて使うことにした
Hugoとは Hugoは静的サイトジェネレーターである。記事をMarkdownで書くことができるのが魅力である。 記事の作成は以下のコマンドで行う
hugo new posts/{title}  以下のコマンドを実行し、localにサーバーを立てて出力を確認しながら書いていく。
hugo server  コンパイルは以下のコマンドで実行し、publicディレクトリ内に結果が出力される。
hugo  なお、私はコンパイル自体は自動化しているのでこのコマンドをうつことはない
GitHub Pagesとは GitHubの提供するWeb hosting serviceである。 GitにCommitするだけでWebが公開できるのである。なにそれ便利。 hugoで作成したpublicディレクトリをアップしてやればよい。 こちらも自動化しているので特に意識してはいない。
時間があるときにここらへんの詳しい話をしたいと思う。</description>
    </item>
    
  </channel>
</rss>